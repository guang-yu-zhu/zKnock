#' Generate knockoff variables using sparse partial least squares (SPLS) regression
#'
#' @details
#' Knockoff variables are generated by fitting an SPLS regression model for each variable based on its neighborhood.
#'
#' **Neighborhood Generation**:
#'  - If `threshold.abs` is given, the absolute correlation threshold is used directly.
#'  - If `threshold.q` is given, neighborhoods are determined based on the quantile of the absolute correlation values.
#'  - If neither is provided, the function defaults to the 90th percentile of the absolute correlation values.
#'
#' **SPLS Regression**:
#' The fitted values of each variable \eqn{X_j} are calculated using the `spls::spls` function. See \code{\link[spls]{spls}} for more details.
#'
#' @param X A numeric matrix or data frame. The design matrix with \eqn{n} observations as rows and \eqn{p} variables as columns.
#' @param ncomp Optional. Integer specifying the number of components to use in the SPLS regression. Default is 2.
#' @param eta Optional. Numeric value between 0 and 1 specifying the sparsity level in the SPLS regression. Default is 0 (no sparsity).
#' @param nb.list Optional. A list of length \eqn{p} or a \eqn{p \times p} adjacency matrix defining the neighborhoods of variables.
#'        If not provided or \code{NULL}, neighborhoods are determined based on correlations.
#' @param threshold.abs Optional. A numeric value between \eqn{0} and \eqn{1} specifying an absolute correlation threshold to define neighborhoods.
#' @param threshold.q Optional. A numeric value between \eqn{0} and \eqn{1} indicating the quantile of the correlation values to use as a threshold. Default is 0.9.
#' @param n_ko Integer. The number of knockoff copies to generate. Default is 1.
#' @param verbose Logical. Whether to display progress information during the knockoff generation. Default is TRUE.
#'
#' @return A matrix of generated knockoff variables of dimensions \eqn{n \times p}.
#'
#' @family create
#'
#' @import spls
#'
#' @examples
#' set.seed(10)
#' X <- matrix(rnorm(100), nrow = 10)
#' Xk <- create.zpls(X = X, ncomp = 3, eta = 0.3)
#'
#' @export
#' @md
create.zpls <- function(X, n_ko = 1, ncomp = NULL, eta = 0, nb.list = NULL, threshold.abs = NULL, threshold.q = 0.9, verbose = FALSE) {
  # Initialize dimensions
  n <- nrow(X)
  p <- ncol(X)

  # Convert data frame to matrix if necessary
  if (is.data.frame(X)) {
    X.names <- names(X)
    X <- as.matrix(X)
  } else if (is.matrix(X)) {
    X.names <- colnames(X)
  } else {
    stop('Input X must be a numeric matrix or data frame')
  }

  # Validate input
  if (!is.numeric(n_ko) || length(n_ko) != 1 || n_ko <= 0 || floor(n_ko) != n_ko) stop("n_ko must be a positive integer.")
  if (!is.numeric(ncomp) || length(ncomp) != 1 || ncomp <= 0 || floor(ncomp) != ncomp) stop("ncomp must be a positive integer.")
  if (!is.numeric(X)) stop('Input X must be a numeric matrix or data frame')
    # Assign default column names if necessary
  if (is.null(X.names)) {
    X.names <- paste0('X', 1:p)
    colnames(X) <- X.names
  }
  # initial X_k
  X_k <- matrix(NA, nrow = n, ncol = p)
  rownames(X_k) <- rownames(X)
  colnames(X_k) <- paste0(X.names, ".tilde")

  # Generate neighborhood list based on correlations if not provided
  if (is.null(nb.list)) {
    sample.order.mat <- diag(1, p, p)[, sample(p)]
    X <- X %*% sample.order.mat
    mu <- colMeans(X)
    X <- scale(X, center = TRUE, scale = FALSE)

    # Calculate the correlation matrix
    cor_mat <- cor(X)
    diag(cor_mat) <- 0

    # Determine correlation threshold
    threshold <- if (!is.null(threshold.abs)) threshold.abs else quantile(abs(cor_mat), prob = threshold.q, names = FALSE)

    # Create neighborhood list
    neighborhoods <- lapply(1:p, function(i) which(abs(cor_mat[i, ]) > threshold))
  } else {
    # Use user-provided neighborhoods
    if (is.list(nb.list)) {
      neighborhoods <- nb.list
    } else if (is.matrix(nb.list) && isSymmetric(nb.list)) {
      neighborhoods <- lapply(1:p, function(i) which(nb.list[i, ] == 1))
    }
  }

  # Determine the number of components if not provided
  if (is.null(ncomp)) {
    r_emp <- r_criterion(X)
  }

  result <- vector("list", length = n_ko)
  for (ko_index in 1:n_ko) {
    if (verbose) cat("-- Generate", ko_index, "knockoffs\n")
    for (i in 1:p) {
      nb <- neighborhoods[[i]]
      k_nb <- nb[nb < i]
      X_nb <- X[, nb]
      X_k_nb <- X_k[, k_nb]

      if (length(nb) == 0) {
        Y <- X[, i]
        Y_hat <- 0
      } else if (length(nb) == 1) {
        X_run <- cbind(X_nb, X_k_nb)
        Y <- X[, i]
        Y_hat <- ols.recovery(Y, X_run)
      } else {
        X_run <- cbind(X_nb, X_k_nb)
        Y <- X[, i]
        this_ncomp <- if (is.null(ncomp)) ceiling(min(ncol(X_nb) / 2, r_emp)) else ncomp
        this_ncomp <- min(this_ncomp, ncol(X_run) - 1)
        Y_hat <- spls.recovery(Y, X_run, ncomp = this_ncomp, eta = eta)
      }

      # Permute residuals and generate knockoff
      Y_res <- Y - Y_hat
      res <- sample(Y_res)
      X_k[, i] <- Y_hat + res
    }

    # Add the mean back to knockoff variables
    X_k <- t(apply(X_k, 1, function(x) x + mu))

    # Restore original column order if neighborhoods were auto-generated
    if (is.null(nb.list)) {
      X_k <- X_k %*% t(sample.order.mat)
    }

    result[[ko_index]] <- X_k
  }

  return(result)
}
